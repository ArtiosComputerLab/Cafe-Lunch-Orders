// ============================================
// ENHANCED ARTIOS CAFE ORDER SYSTEM WITH FIXED CANCELLATIONS
// ============================================
const SHEET_ID = '1vBlYUsY7lt0k4x7I_OxvjYbHvQn0hbR6HwHh_aCsHxA';
const ORDERS_SHEET = 'Orders';
const CANCELLATIONS_SHEET = 'Cancellations';
const NOTIFICATION_EMAIL = 'jedaws@gmail.com';

// ============================================
// ORDER LOOKUP AND CANCELLATION FUNCTIONS
// ============================================

/**
 * Look up orders by email and optional order ID
 */
function lookupOrders(email, orderId = null) {
  try {
    console.log(`Looking up orders for email: ${email}, orderId: ${orderId}`);
    
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(ORDERS_SHEET);
    const data = sheet.getDataRange().getValues();
    
    const orderMap = {};
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      if (row[1] === email) { // Email column
        if (!orderId || row[7] === orderId) { // Order ID column
          const currentOrderId = row[7];
          
          if (!orderMap[currentOrderId]) {
            orderMap[currentOrderId] = {
              orderId: currentOrderId,
              timestamp: row[0],
              email: row[1],
              items: [],
              children: [],
              subtotal: row[13] || 0,
              discount: row[14] || 0,
              total: row[15] || 0,
              promoCode: row[16] || ''
            };
          }
          
          // Parse item data
          const itemData = JSON.parse(row[5])[0]; // First item in array
          const itemStatus = row[17] || 'active'; // Status column
          
          // FIXED: Ensure date is properly formatted as YYYY-MM-DD string
          let itemDateStr = '';
          if (row[11] instanceof Date) {
            itemDateStr = row[11].toISOString().split('T')[0];
          } else if (typeof row[11] === 'string') {
            // Handle various string formats
            if (row[11].includes('T')) {
              itemDateStr = row[11].split('T')[0];
            } else {
              itemDateStr = row[11];
            }
          } else {
            console.log(`Row ${i}: Unexpected itemDate format:`, row[11], typeof row[11]);
            continue;
          }
          
          orderMap[currentOrderId].items.push({
            id: `${currentOrderId}-${i}`, // Unique item ID
            rowIndex: i,
            name: itemData.name,
            price: parseFloat(row[6]) || 0,
            day: itemData.day,
            childId: row[10] || '1',
            childName: `${row[2]} ${row[3]}`, // First + Last name
            grade: row[4],
            date: itemDateStr, // FIXED: Always return as YYYY-MM-DD string
            status: itemStatus,
            cancellationDate: row[18] || null,
            refundAmount: parseFloat(row[19]) || 0
          });
          
          // Track unique children
          const childKey = `${row[2]} ${row[3]}`;
          if (!orderMap[currentOrderId].children.find(c => c.name === childKey)) {
            orderMap[currentOrderId].children.push({
              id: row[10] || '1',
              firstName: row[2],
              lastName: row[3],
              name: childKey,
              grade: row[4]
            });
          }
        }
      }
    }
    
    const orders = Object.values(orderMap);
    console.log(`Found ${orders.length} orders for ${email}`);
    
    return {
      success: true,
      orders: orders,
      count: orders.length
    };
    
  } catch (error) {
    console.error('Error in lookupOrders:', error);
    throw error;
  }
}

/**
 * Process item cancellation with FIXED time-based validation
 */
function processCancellation(itemId, reason) {
  try {
    console.log(`Processing cancellation for item: ${itemId}, reason: ${reason}`);
    
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(ORDERS_SHEET);
    const data = sheet.getDataRange().getValues();
    
    // Find the item by ID (format: ORDERID-ROWINDEX)
    const [orderId, rowIndexStr] = itemId.split('-');
    const rowIndex = parseInt(rowIndexStr);
    
    if (!rowIndex || rowIndex >= data.length) {
      throw new Error('Invalid item ID');
    }
    
    const row = data[rowIndex];
    
    // FIXED: Better date handling for cancellation deadline
    let itemDate;
    if (row[11] instanceof Date) {
      itemDate = new Date(row[11]);
    } else if (typeof row[11] === 'string') {
      if (row[11].includes('T')) {
        itemDate = new Date(row[11].split('T')[0] + 'T00:00:00');
      } else {
        itemDate = new Date(row[11] + 'T00:00:00');
      }
    } else {
      throw new Error('Invalid item date format');
    }
    
    // Set cutoff to 8:15 AM on the item's day
    const cutoffTime = new Date(itemDate);
    cutoffTime.setHours(8, 15, 0, 0);
    
    const now = new Date();
    
    console.log(`Item date: ${itemDate.toISOString()}`);
    console.log(`Cutoff time: ${cutoffTime.toISOString()}`);
    console.log(`Current time: ${now.toISOString()}`);
    console.log(`Can cancel: ${now < cutoffTime}`);
    
    if (now >= cutoffTime) {
      return {
        success: false,
        message: `Cannot cancel - past 8:15 AM deadline for ${itemDate.toDateString()}`,
        deadline: cutoffTime.toISOString(),
        currentTime: now.toISOString()
      };
    }
    
    // Item can be cancelled - update database
    const itemData = JSON.parse(row[5])[0];
    const refundAmount = parseFloat(row[6]) || 0;
    
    // Update the row with cancellation info
    const range = sheet.getRange(rowIndex + 1, 1, 1, sheet.getLastColumn());
    const updatedRow = [...row];
    
    // Add new columns if they don't exist
    while (updatedRow.length < 21) {
      updatedRow.push('');
    }
    
    updatedRow[17] = 'cancelled'; // Status column
    updatedRow[18] = new Date().toISOString(); // Cancellation date
    updatedRow[19] = refundAmount; // Refund amount
    updatedRow[20] = reason; // Cancellation reason
    
    range.setValues([updatedRow]);
    
    // Log the cancellation
    logCancellation(orderId, itemData, refundAmount, reason, row[1]); // row[1] is email
    
    // Send notifications
    const orderInfo = {
      orderId: orderId,
      email: row[1],
      childName: `${row[2]} ${row[3]}`,
      itemName: itemData.name,
      itemDay: itemData.day,
      itemDate: itemDate,
      refundAmount: refundAmount,
      reason: reason
    };
    
    sendParentCancellationConfirmation(orderInfo);
    sendAdminRefundNotification(orderInfo);
    
    console.log(`Successfully cancelled item: ${itemData.name} for ${orderInfo.childName}`);
    
    return {
      success: true,
      message: `${itemData.name} cancelled successfully. Refund of $${refundAmount.toFixed(2)} will be processed within 24 hours.`,
      refundAmount: refundAmount,
      cancellationDate: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('Error in processCancellation:', error);
    throw error;
  }
}

// ============================================
// MAIN FUNCTIONS (keeping the same doGet and doPost)
// ============================================

function doGet(e) {
  try {
    const action = e.parameter.action;
    console.log('doGet called with action:', action);
    
    if (action === 'test' || e.parameter.test === 'true') {
      return ContentService
        .createTextOutput(JSON.stringify({
          success: true,
          message: 'Google Apps Script is working correctly!',
          timestamp: new Date().toISOString(),
          sheetId: SHEET_ID,
          features: ['orders', 'cancellations', 'email_reports', 'refunds']
        }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    // Handle order lookup for management portal
    if (action === 'lookup_orders') {
      const email = e.parameter.email;
      const orderId = e.parameter.order_id;
      
      if (!email) {
        return ContentService
          .createTextOutput(JSON.stringify({
            success: false,
            error: 'Email parameter required'
          }))
          .setMimeType(ContentService.MimeType.JSON);
      }
      
      try {
        const result = lookupOrders(email, orderId);
        return ContentService
          .createTextOutput(JSON.stringify(result))
          .setMimeType(ContentService.MimeType.JSON);
      } catch (lookupError) {
        console.error('Order lookup error:', lookupError);
        return ContentService
          .createTextOutput(JSON.stringify({
            success: false,
            error: `Order lookup failed: ${lookupError.toString()}`
          }))
          .setMimeType(ContentService.MimeType.JSON);
      }
    }
    
    // Handle item cancellation
    if (action === 'cancel_item') {
      const itemId = e.parameter.item_id;
      const reason = e.parameter.reason || 'Parent requested';
      
      if (!itemId) {
        return ContentService
          .createTextOutput(JSON.stringify({
            success: false,
            error: 'Item ID parameter required'
          }))
          .setMimeType(ContentService.MimeType.JSON);
      }
      
      try {
        const result = processCancellation(itemId, reason);
        return ContentService
          .createTextOutput(JSON.stringify(result))
          .setMimeType(ContentService.MimeType.JSON);
      } catch (cancellationError) {
        console.error('Cancellation error:', cancellationError);
        return ContentService
          .createTextOutput(JSON.stringify({
            success: false,
            error: `Cancellation failed: ${cancellationError.toString()}`
          }))
          .setMimeType(ContentService.MimeType.JSON);
      }
    }
    
    // Generate email report
    if (action === 'generate_report') {
      const secret = e.parameter.secret;
      if (secret !== 'cafe2025') {
        return ContentService
          .createTextOutput(JSON.stringify({
            success: false,
            error: 'Invalid secret key'
          }))
          .setMimeType(ContentService.MimeType.JSON);
      }
      
      try {
        const dateParam = e.parameter.date;
        let reportDate;
        
        if (dateParam) {
          reportDate = new Date(dateParam + 'T12:00:00');
          if (isNaN(reportDate.getTime())) {
            throw new Error('Invalid date format. Use YYYY-MM-DD');
          }
        } else {
          reportDate = new Date();
        }
        
        const result = generateEmailOnlyReport(reportDate);
        
        const adminRecipientsParam = e.parameter.admin_recipients || '';
        const workerRecipientsParam = e.parameter.worker_recipients || '';
        
        const adminRecipients = adminRecipientsParam.split(',').map(email => email.trim()).filter(email => email);
        const workerRecipients = workerRecipientsParam.split(',').map(email => email.trim()).filter(email => email);
        
        console.log('Admin recipients:', adminRecipients);
        console.log('Worker recipients:', workerRecipients);
        
        if (adminRecipients.length > 0) {
          console.log('Sending admin reports');
          adminRecipients.forEach(email => {
            sendEnhancedReportNotificationEmail(result, reportDate, true, email);
          });
        }
        
        if (workerRecipients.length > 0) {
          console.log('Sending worker reports');
          workerRecipients.forEach(email => {
            sendComprehensiveCafeWorkerEmail(result, reportDate, email);
          });
        }
        
        return ContentService
          .createTextOutput(JSON.stringify({
            success: true,
            message: 'Email report sent successfully',
            ordersProcessed: result.orderCount,
            reportDate: reportDate.toISOString().split('T')[0],
            emailSent: true,
            adminEmailsSent: adminRecipients.length,
            workerEmailsSent: workerRecipients.length
          }))
          .setMimeType(ContentService.MimeType.JSON);
        
      } catch (reportError) {
        console.error('Report generation error:', reportError);
        return ContentService
          .createTextOutput(JSON.stringify({
            success: false,
            error: `Report generation failed: ${reportError.toString()}`
          }))
          .setMimeType(ContentService.MimeType.JSON);
      }
    }
    
    return ContentService
      .createTextOutput(JSON.stringify({
        success: false,
        error: 'Unknown action: ' + action
      }))
      .setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    console.error('Error in doGet:', error);
    return ContentService
      .createTextOutput(JSON.stringify({
        success: false,
        error: error.toString()
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// [Rest of the Apps Script functions remain the same - doPost, email functions, etc.]
// I'm only showing the key fixes for date handling in lookup and cancellation
